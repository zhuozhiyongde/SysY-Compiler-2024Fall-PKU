# Lv9

## Koopa

### 数组初始化

数组初始化的思路如下：

1. 使用 `vector<int> indices` 收集所有的数组维度
2. 计算总共的元素个数 `total`
3. 真的去分配一个 `int arr[total]` 的数组在堆上，然后往里面存数据。
4. 使用递归去做，递归函数签名为 `void init(const vector<int>& indices, int*& arr, int& cur, int align)`，其中：
   - `indices` 是存放数组维度的 `vector<int>`
   - `arr` 是真实分配数组指针
   - `cur` 是当前分配到的数组下标
   - `align` 是当前对齐步长

递归函数的主要逻辑如下：

1. 计算每个维度的步长（使用连乘法遍历），并存储在 `vector<int> steps` 中。
2. 如果 `init_values` 为空（即单个 `{}`），直接填充一个 `0`，避免没走遍历直接判断对齐，然后直接跳过了，填 `0` 可以保证后续对齐的时候能走满一个步长。
3. 遍历 `init_values`：
   - 如果是整数，直接赋值到 `arr` 中，并递增 `cur`。
   - 如果是初始化列表，找到合适的步长进行递归初始化。
4. 最后，对齐到 `align`，在 `cur` 不满足对齐要求时填充 `0`。

其他的注意事项：

首先，局部数组不能用 zeroinit 初始化，这个只能在全局数组中使用。

其次，要考虑形如 `{}` 的初始化，这个东西只要出现，就至少会初始化掉一个步长。

如果你发现在 `22_arr_init1` 测试点 WA，那么就很有可能是此原因导致的，你可以本地测试如下测试点：

```c
const int buf[3][3][1] = { 1,{},2 };
```

这个测试点的输出应当是

```
alloc [[[i32, 1], 3], 3], {{{1}, {0}, {2}}, {{0}, {0}, {0}}, {{0}, {0}, {0}}}
```

如果你仅仅在处理第二个 `{}` 的时候检查对齐，而不考虑其 `init_values` 为空，一上来就对齐导致完全没有补 0 进而被直接跳过，那么很容易得到：

```
alloc [[[i32, 1], 3], 3], {{{1}, {2}, {0}}, {{0}, {0}, {0}}, {{0}, {0}, {0}}}
```

而这是错误的。

除此之外，你还需要小心

```c
int d[5][3] = { {1, 2, 3}, {4, 5, 6}, {7, 8, 9}, {10, 11, 12}, {13, 14, 15} };
```

这样一上来就是 `{}` 的初始化，这时候对齐要特殊处理，因为此时容易误判对齐步长为 15，而不是正确的 3。

### 数组存值、访问

我新增加了两个符号类型：

- `ARR`：表示数组
- `PTR`：表示指针

他们对应的 `value` 为其定值时知道的维度个数。

- 对于 `ARR` 来说，`value` 为维度个数
- 对于 `PTR` 来说，`value` 为指针指向的维度个数，若声明为 `int[]` 则记为 1，若声明为 `int[][3]` 则记为 2，注意这里要判断对于 AST 那个 vector 的个数 + 1，对应那个没有显式表达式的 `[]` 维度

为什么要这么做？因为一个 LVal 出现的位置是不确定的，其既可以作为值，也可以作为指针参数去调用函数，我们必须判断其是哪种情况，进而输出不同的 KoopaIR。

而判断的方法，就是看我们调用他们所使用的维度个数，相对于我们初始化他们时的维度个数的关系。

- 若调用时使用的维度个数等于初始化时知道的维度个数，则其为值
- 若调用时使用的维度个数小于初始化时知道的维度个数，则其为指针

而 `ARR` 和 `PTR` 在首条加载指令的时候亦有差异，所以也要分开处理一下。

## Riscv

数组的分配必须在 ALLOC 时进行处理，否则如果在 GET_ELEM_PTR 时再进行处理就会导致因为要存储中间结果，所以需要在两个连续的 store 之间插入中间结果，进而导致数组分配不连续，后续无法计算偏移。

```c
int main() {
  int b[2][3] = { 1, 2, 3, 4 };
  putint(b[0][1]);
  putch(10);
  return 0;
}
```

测试输出是 4 还是 2？

狗日的 step 不一定是 4，还得展开才行。

对于指针，都需要进行一个 `lw t0 0(t0)` 的操作来取值。

## Debug

发现过完本地之后远程 lv9 也能全过，但是 final 会有过不去的，执行：

```bash
autotest -riscv /root/compiler
```

发现有几个先前 lv3 的测试点过不去了，仔细检查了一下发现是短路计算的问题，原先的写法是：

```cpp
if (logical_op == LogicalOp::LOGICAL_OR) {
    // 左侧为立即数
    if (lhs.type == Result::Type::IMM) {
      if (lhs.value != 0) {
        return IMM_(1);
      }
      else {
        Result rhs = right->print();
        return rhs;
      }
    }
    // ...
}
```

这种写法有一个问题，逻辑表达式返回的必然是一个布尔型，也就是要么是 1 要么是 0，所以我们在判断 `rhs` 的时候不能直接返回，而是：

1. 检查一下其值是否为立即数，若是，则返回 `rhs.value != 0`
2. 若非立即数而是寄存器，直接返回 `rhs`

也即：

```cpp
if (logical_op == LogicalOp::LOGICAL_OR) {
    // 左侧为立即数
    if (lhs.type == Result::Type::IMM) {
      if (lhs.value != 0) {
        return IMM_(1);
      }
      else {
        Result rhs = right->print();
        if (rhs.type == Result::Type::IMM) {
          return IMM_(rhs.value != 0);
        }
        else {
          return rhs;
        }
      }
    }
    // ...
}
```

对于 `&&` 运算同理，不再赘述。
